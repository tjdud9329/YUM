#다차원 배열과 이중 포인터

1. 2차원 배열 선언 : type arr1[세로길이(행)][가로길이(열)]
2. 배열의 사이즈가 빌 때 > 컴파일러가 채워넣을 숫자를 결정하지 못함
3. 가로길이(열) > 필수로 선언 필요 (컴파일러가 세로길이는 계산해주기 때문)
4. 삼차원 배열 선언 : type arr2[층][행][열]
5. 이중 포인터 변수 : 주소의 주소 >> 포인터변수도 변수이므로 포인터 변수를 가리키는 이중 포인터 변수 존재
6. *(dptr) == num

```c
#include <stdio.h>

int main(void) {
  int num1 = 10, num2 = 20, num3 = 30;
  int *ptr1 = &num1;
  int *ptr2 = &num2;
  int *ptr3 = &num3;
  int *ptrArr[]={ptr1, ptr2, ptr3};
  int **dptr = ptrArr;
  printf("%d %d %d\n", *(ptrArr[0]), *(ptrArr[1]), *(ptrArr[2]));
  printf("%d %d %d\n", *(dptr[0]), *(dptr[1]), *(dptr[2]));
  return 0;
 ```

7. 포인터의 필요성 : 함수내에서 함수 외부의 접근 허용
8. 동적할당 : 메모리를 오가며 접근하기에 필요
9. 자료구조 : 배열에 저장하여 이용(가끔)

#함수 포인터와 void 포인터
1. 함수의 이름 : 함수가 저장된 메모리 공간을 가리키는 포인터
2. 함수 포인터 변수 : 함수의 이름이 의미하는 주소값을 저장 >> 반환형, 매개변수 선언의 정보를 담고있음(반환형과 매개변수가 동일하면 포인터형도 동일)
3. 함수 포인터 선언 > int (*fptr)(int,int)
4. void, 포인터 > 어떠한 주소겂도 저장 가능 > 형 정보가 없으므로 메모리 접근을 위한 *연산은 불가능
5. int main(int argc, char *argv[]) {} >> main 함수를 통한 인자 전달

#메모리 동적할당 
1. 메모리구조 : 코드영역(코드 저장)/데이터영역(전역변수, STATIC변수 등 종료시까지 남아있는 변수)/힙 영역(자유 공간)/스택 영역(지역변수, 매겨변수 등 함수에서 나갈 때 소멸되는 변수)
2. 전역변수 할당 > 함수 실행 시 스택영역에 변수들이 쌓임
3. 동적할당 : 특정 기간동안 메모리를 이용할 경우가 생김{ex)함수 내에서 생성한 변수가 계속 사용되고 싶을 때} > 자유공간인 힙 사용
```c
#include <stdlib.h> //반환형이 void 형 포인트이기 때문

void * malloc(size_t size); //힙 영역으로의 메모리 공간 할당
void free(void * ptr); //힙 영역에 할당된 메모리 공간 해제
//malooc 함수는 성공시 할당된 메모리 주소 값, 실패시 NULL 반환
 ```
4. malloc 함수 > 인자로 사이즈만 입력받으므로 메모리 용도를 모름 > 포인터형 결정 불가 >> 형변환을 통해서 이용 가능

```c
#include <stdlib.h> //반환형이 void 형 포인트이기 때문

int main(int argc, char *argv[] {
  int *ptr = (int *)malloc(size:sizeof(int)); }
 ```
5. free함수를 호출하지 않을 떄 > 할당된 메모리 공간을 계속 차지 > 프로그램 종료 후 공간 반환
6. calloc 함수 : 개수, 사이즈를 둘 다 입력 받아서 한번에 할당 > malloc과 달리 모든 비트를 0으로 초기화
7. realloc 함수 : ptr이 가리키는 힙의 메모리 공간의 사이즈 변화

