#진수 체계와 컴퓨터

1. 진수에도 올림체계가 존재함 >> 0 = 0000 1 = 0001 2 = 0010 3 = 0011 4 = 0100 ... (2진수 = 4비트)
2. 2진수 = **%d**, 8진수 = **%o**, 16진수 = **%x** 로 표현

#배열과 문자열

int arr1 [4]
1. 길이를 할당해주는 것이 필요
2. 할당해준 길이보다 적은 값이 주어지면 자동으로 0이 채워짐
3. int arr [5] = {1,2} = {1,2,0,0,0};
4. int arr[] = {1, 2, 3, 4, 5, 6}; -> 배열의 크기가 6으로 선언된 것임
   
char str [14] = "Good morning!";
1. 띄어쓰기, 기호 포함 13 + 널 문자 1 = 14
2. **널문자("\0")** = 문자열 끝에 삽입되어 문자열의 끝을 의미
3. 널문자가 있으면 **문자열**, 없으면 **문자 배열**의 의미를 지님
4. 배열의 길이 =/= 문자열의 길이
5. printf > 널 문자 만나기 전까지를 문자열로 보고 출력함
```c
char str[50] = " I like C programming";
printf("string: %s \n", str);
/*string: I like C programming
str[8] = '\0';
printf("string: %s \n", str);
/*string: I like C
```

#포인터 
1. **포인터 변수** : 정수 형태로 된 **주소값**을 저장하는 목적으로 선언 > **하나의 자료형**
2. * (1): 포인터 변수에 쓰임 >  포인터 변수 선언시 자료형에 맞춰서 저장 (int num 이면 int *pnum 으로)
3. & : 변수의 주소값을 알아낼때 쓰임 > 주소값을 반환함 > 변수가 피연산자가 되고, 반환값은 포인터 변수에 저장됨
4. int num;(정수형 변수 선언) int *pnum; (정수형 포인터 변수 선언) pnum = &num;(변수의 주소값을 포인터 변수에 저장)
5. pnum 안에 num의 주소가 저장 되어 이쏙, 이 주소는 num 변수를 가리킴 > >> 포인터 변수 pnum 이 변수 num을 가리킴
6. *(2) : 포인터가 가리키는 메모리를 참조하는 연산자로 쓰임 > 선언된 포인터 변수에 * 를 붙이면 기존 변수의 값을 참조 하게됨
7. **널 포인터** : 포인터 변수의 값을 0 또는 NULL로 초기화(아무것도 가리키지 않음)

#포인터와 배열
1. **배열의 이름 = 포인터변수 = 배열[0]**
2. 배열의 이름은 배열의 시작주소값의 포인터를 가리킴 > int arr[3] = {1,2,3}; 일때 arr = &arr[0] 성립  *arr의 값 = 1 성립  >> 배열의 이름을 포인터처럼 사용 가능
3. 배열의 이름이 가리키는 변수의 자료형을 근거로 포인터 형 결정 = int형 변수를 가리킬 시 int*형 = int arr[n]에서 arr은 int*형
4. 포인터 변수의 저장된 값 증감연산 가능 > 포인터 변수 대상으로 증감 시 자료형만큼 증감 >> int*는 4씩, char*는 1씩 증감 >> **arr[n] == *(arr+n)**

##문자열
1. char str[] = "My String"; >> 문자열이 저장된 **배열** : 변수 성향(변경 가능)
2. char *str = "Your String"; >> **문자열의 주소값**을 저장하는 방식 : 상수성향(변경 불가능)
3. 문자열이 출력 시 주소값이 전달됨 > 널 문자가 있어야 문자열에 대한 정보가 전달될 수 있음
4. 포인터 배열 > 일반배열과 차이점 없음, 변수의 자료형이 int*, double* 등이 됨

#포인터와 함수
1. 이자 전달의 기본 방식 : 복사
2. C언어에서 매개변수로 배열 사용 불가 > 배열은 주소값을 전달하는 방식 사용
3. 배열의 인자로 포인터 변수를 전달하면 배열처럼 사용 가능 > void Functinon(int *param(포인터변수를 인자로 전달)) {print ("%d\n", param[0](포인터로 사용가능));}
4. void Functinon(int param[](배열임을 명확히 함)) {print ("%d\n", param[0]);}
5. call-by-value : 함수 호출 시 단순히 값만 전달 (함수 외부에 선언된 변수에 접근 불가)
6. call-by-reference : 메모리 접근에 사용되는 주소값 전달 (함수 외부에 선언된 변수에 접근 가능) >>> 함수의 인자로 전달되는 대상에 따라 구별가능

```c
#include <stdio.h>

void Swap(int *ptr1, int *ptr2){
   int a = *ptr1;
   *ptr1 = *ptr2;
   *ptr2 = a;
}

int main(void) {
   int num1 = 10, num2 = 20;
   printf("Before Swap : %d, %d\n" num1, num2);
   Swap(**&**num1, **&**num2);
   printf("After Swap : %d, %d\n", num1, num2);
   return0;
}
 ```
